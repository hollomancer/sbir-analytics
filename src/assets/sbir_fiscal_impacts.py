"""Dagster assets for SBIR fiscal impact analysis.

Calculates tax revenue and job creation impacts from SBIR awards using
StateIO economic models.
"""

import pandas as pd
from dagster import (
    AssetCheckResult,
    AssetCheckSeverity,
    AssetExecutionContext,
    Output,
    asset,
    asset_check,
)

from ..config.loader import get_config
from ..transformers.sbir_fiscal_pipeline import SBIRFiscalImpactCalculator
from ..utils.monitoring import performance_monitor


@asset(
    description="SBIR fiscal impacts: tax revenue and jobs by state and industry",
    group_name="fiscal_analysis",
    compute_kind="r_economic_model",
)
def sbir_fiscal_impacts(
    context: AssetExecutionContext,
    enriched_sbir_awards: pd.DataFrame,
) -> Output[pd.DataFrame]:
    """Calculate fiscal and employment impacts from SBIR awards.

    Uses StateIO economic models to estimate:
    - Tax revenue generated by state and industry
    - Jobs created by state and industry
    - Production multiplier effects
    - Wage and income impacts

    Args:
        enriched_sbir_awards: SBIR awards enriched with NAICS codes from USAspending

    Returns:
        DataFrame with fiscal impacts by state/sector/year
    """
    config = get_config()

    context.log.info(f"Calculating fiscal impacts for {len(enriched_sbir_awards)} SBIR awards")

    # Check for required columns
    required_cols = ["award_id", "total_obligated_amount", "state", "naics_code", "fiscal_year"]
    missing_cols = [col for col in required_cols if col not in enriched_sbir_awards.columns]

    if missing_cols:
        context.log.error(f"Missing required columns: {missing_cols}")
        # Return empty DataFrame with expected schema
        return Output(
            value=pd.DataFrame(
                columns=[
                    "state",
                    "bea_sector",
                    "fiscal_year",
                    "award_total",
                    "production_impact",
                    "wage_impact",
                    "tax_impact",
                    "jobs_created",
                ]
            ),
            metadata={
                "error": "Missing required columns",
                "missing_columns": missing_cols,
            },
        )

    # Prepare awards for fiscal pipeline
    # Map column names to expected format
    awards_for_fiscal = enriched_sbir_awards.rename(
        columns={
            "total_obligated_amount": "award_amount",
            # Keep award_id, state, naics_code, fiscal_year as-is
        }
    )[["award_id", "award_amount", "state", "naics_code", "fiscal_year"]].copy()

    # Remove rows with missing critical data
    initial_count = len(awards_for_fiscal)
    awards_for_fiscal = awards_for_fiscal.dropna(
        subset=["award_amount", "state", "naics_code", "fiscal_year"]
    )
    dropped_count = initial_count - len(awards_for_fiscal)

    if dropped_count > 0:
        context.log.warning(f"Dropped {dropped_count} awards with missing fiscal data")

    if len(awards_for_fiscal) == 0:
        context.log.error("No valid awards remaining after filtering")
        return Output(
            value=pd.DataFrame(),
            metadata={"error": "No valid awards", "dropped_count": dropped_count},
        )

    # Initialize fiscal calculator
    try:
        with performance_monitor.monitor_block("fiscal_impact_calculation"):
            calculator = SBIRFiscalImpactCalculator(config=config)

            context.log.info("Running fiscal impact calculations...")
            impacts = calculator.calculate_impacts_from_sbir_awards(
                awards_for_fiscal, include_employment=True
            )

            context.log.info(f"Generated {len(impacts)} impact records")

    except Exception as e:
        context.log.error(f"Fiscal impact calculation failed: {e}")
        raise

    # Calculate summary statistics
    total_awards = float(impacts["award_total"].sum()) if len(impacts) > 0 else 0
    total_tax = float(impacts["tax_impact"].sum()) if len(impacts) > 0 else 0
    total_jobs = float(impacts["jobs_created"].sum()) if len(impacts) > 0 else 0
    total_production = float(impacts["production_impact"].sum()) if len(impacts) > 0 else 0

    # Calculate multipliers
    production_multiplier = total_production / total_awards if total_awards > 0 else 0
    tax_multiplier = total_tax / total_awards if total_awards > 0 else 0
    jobs_per_million = (total_jobs / total_awards) * 1_000_000 if total_awards > 0 else 0

    # Count quality distribution
    quality_dist = impacts["quality_flags"].value_counts().to_dict() if len(impacts) > 0 else {}

    return Output(
        value=impacts,
        metadata={
            "record_count": len(impacts),
            "total_awards": total_awards,
            "total_tax_revenue": total_tax,
            "total_jobs_created": total_jobs,
            "total_production_impact": total_production,
            "production_multiplier": production_multiplier,
            "tax_multiplier": tax_multiplier,
            "jobs_per_million": jobs_per_million,
            "states_analyzed": impacts["state"].nunique() if len(impacts) > 0 else 0,
            "sectors_analyzed": impacts["bea_sector"].nunique() if len(impacts) > 0 else 0,
            "quality_distribution": quality_dist,
            "dropped_awards": dropped_count,
        },
    )


@asset(
    description="State-level fiscal impact summary",
    group_name="fiscal_analysis",
    compute_kind="aggregation",
)
def sbir_fiscal_impacts_by_state(
    context: AssetExecutionContext,
    sbir_fiscal_impacts: pd.DataFrame,
) -> Output[pd.DataFrame]:
    """Aggregate fiscal impacts by state.

    Args:
        sbir_fiscal_impacts: Detailed fiscal impacts

    Returns:
        State-level summary with total awards, tax, jobs
    """
    if len(sbir_fiscal_impacts) == 0:
        context.log.warning("No fiscal impacts to summarize")
        return Output(value=pd.DataFrame())

    calculator = SBIRFiscalImpactCalculator()
    state_summary = calculator.calculate_summary_by_state(sbir_fiscal_impacts)

    context.log.info(f"Generated state summary for {len(state_summary)} states")

    # Calculate summary statistics
    total_states = len(state_summary)
    top_state = (
        state_summary.nlargest(1, "total_tax_impact")["state"].iloc[0]
        if len(state_summary) > 0
        else None
    )
    top_state_tax = (
        float(state_summary.nlargest(1, "total_tax_impact")["total_tax_impact"].iloc[0])
        if len(state_summary) > 0
        else 0
    )

    return Output(
        value=state_summary,
        metadata={
            "total_states": total_states,
            "top_state_by_tax": top_state,
            "top_state_tax_impact": top_state_tax,
        },
    )


@asset(
    description="Industry sector-level fiscal impact summary",
    group_name="fiscal_analysis",
    compute_kind="aggregation",
)
def sbir_fiscal_impacts_by_sector(
    context: AssetExecutionContext,
    sbir_fiscal_impacts: pd.DataFrame,
) -> Output[pd.DataFrame]:
    """Aggregate fiscal impacts by industry sector.

    Args:
        sbir_fiscal_impacts: Detailed fiscal impacts

    Returns:
        Sector-level summary with descriptions and totals
    """
    if len(sbir_fiscal_impacts) == 0:
        context.log.warning("No fiscal impacts to summarize")
        return Output(value=pd.DataFrame())

    calculator = SBIRFiscalImpactCalculator()
    sector_summary = calculator.calculate_summary_by_sector(sbir_fiscal_impacts)

    context.log.info(f"Generated sector summary for {len(sector_summary)} sectors")

    # Calculate summary statistics
    total_sectors = len(sector_summary)
    top_sector = (
        sector_summary.nlargest(1, "total_tax_impact")["bea_sector"].iloc[0]
        if len(sector_summary) > 0
        else None
    )
    top_sector_desc = (
        sector_summary.nlargest(1, "total_tax_impact")["sector_description"].iloc[0]
        if len(sector_summary) > 0
        else None
    )

    return Output(
        value=sector_summary,
        metadata={
            "total_sectors": total_sectors,
            "top_sector_by_tax": top_sector,
            "top_sector_description": top_sector_desc,
        },
    )


@asset_check(asset=sbir_fiscal_impacts, description="Verify fiscal impacts have valid data")
def check_fiscal_impacts_quality(
    context: AssetExecutionContext,
    sbir_fiscal_impacts: pd.DataFrame,
) -> AssetCheckResult:
    """Check quality of fiscal impact calculations."""
    if len(sbir_fiscal_impacts) == 0:
        return AssetCheckResult(
            passed=False,
            severity=AssetCheckSeverity.ERROR,
            description="No fiscal impacts generated",
        )

    # Check for high-quality results (using actual StateIO ratios)
    high_quality = sbir_fiscal_impacts[
        sbir_fiscal_impacts["quality_flags"].str.contains("stateio_ratios", na=False)
    ]

    high_quality_pct = len(high_quality) / len(sbir_fiscal_impacts) * 100

    # Check average confidence
    avg_confidence = float(sbir_fiscal_impacts["confidence"].mean())

    # Check for any failed computations
    failed = sbir_fiscal_impacts[
        sbir_fiscal_impacts["quality_flags"].str.contains("failed", na=False)
    ]
    failed_pct = len(failed) / len(sbir_fiscal_impacts) * 100

    # Determine pass/fail
    passed = avg_confidence >= 0.7 and failed_pct < 10

    severity = AssetCheckSeverity.WARN if not passed else AssetCheckSeverity.INFO  # type: ignore[attr-defined]

    return AssetCheckResult(
        passed=passed,
        severity=severity,  # type: ignore[arg-type]
        description=(
            f"Quality check: {high_quality_pct:.1f}% high quality, "
            f"{avg_confidence:.2%} avg confidence, "
            f"{failed_pct:.1f}% failed"
        ),
        metadata={
            "high_quality_percentage": high_quality_pct,
            "average_confidence": avg_confidence,
            "failed_percentage": failed_pct,
            "total_records": len(sbir_fiscal_impacts),
        },
    )
