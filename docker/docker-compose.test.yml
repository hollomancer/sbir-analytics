services:
  # Ephemeral Neo4j instance for CI tests - optimized for MacBook Air
  neo4j:
    image: neo4j:5.20.0
    container_name: sbir-neo4j-ci
    environment:
      # Use env file (.env) created by the workflow to inject credentials
      - NEO4J_AUTH=${NEO4J_USER}/${NEO4J_PASSWORD}
      - NEO4J_PLUGINS=${NEO4J_PLUGINS:-'["apoc"]'}
      # MacBook Air optimized memory settings
      - NEO4J_server_memory_pagecache_size=${NEO4J_server_memory_pagecache_size:-256M}
      - NEO4J_server_memory_heap_max__size=${NEO4J_server_memory_heap_max__size:-1G}
      - NEO4J_server_memory_heap_initial__size=512M
      # Performance optimizations for testing
      - NEO4J_server_db_checkpoint_interval_time=30s
      - NEO4J_server_db_checkpoint_interval_tx=1000
      # Reduce logging for performance
      - NEO4J_server_logs_debug_level=WARN
      - NEO4J_server_logs_query_enabled=false
    ports:
      - "7474:7474" # HTTP
      - "7687:7687" # Bolt
    volumes:
      - neo4j_data_ci:/data
      - neo4j_logs_ci:/logs
      - neo4j_import_ci:/var/lib/neo4j/import
    networks:
      - sbir-network
    # Enhanced health check with timeout and startup period
    healthcheck:
      test:
        [
          "CMD-SHELL",
          "cypher-shell -u ${NEO4J_USER} -p ${NEO4J_PASSWORD} 'RETURN 1' >/dev/null 2>&1",
        ]
      interval: 10s
      timeout: 10s
      retries: 15
      start_period: 30s
    # Resource limits for MacBook Air compatibility
    deploy:
      resources:
        limits:
          memory: 2G
          cpus: '1.0'
        reservations:
          memory: 1G
          cpus: '0.5'
    restart: "no"

  # App service: use the image built earlier in the workflow and run pytest
  app:
    image: sbir-etl:ci-${GITHUB_SHA}
    container_name: sbir-app-test
    env_file:
      - .env
    environment:
      - ENVIRONMENT=test
      - PYTHONPATH=/app
      - NEO4J_URI=bolt://neo4j:7687
      - NEO4J_USERNAME=${NEO4J_USER}
      - NEO4J_PASSWORD=${NEO4J_PASSWORD}
      # Provide SBIR_ETL connection settings pointing at the test Neo4j service
      - SBIR_ETL__NEO4J__BOLT_URL=bolt://neo4j:7687
      - SBIR_ETL__NEO4J__USERNAME=${NEO4J_USER}
      - SBIR_ETL__NEO4J__PASSWORD=${NEO4J_PASSWORD}
      # USPTO raw data directory inside container (mounted from repo workspace)
      - SBIR_ETL__USPTO__RAW_DIR=/app/data/raw/uspto
      - PYTHONUNBUFFERED=1
      # Allow coverage artifacts to write to a writable location since /app is mounted read-only
      - COVERAGE_FILE=/tmp/.coverage
      - COVERAGE_HTML_DIR=/tmp/htmlcov
      # Test execution timeout
      - TEST_TIMEOUT=${TEST_TIMEOUT:-600}
    depends_on:
      neo4j:
        condition: service_healthy
    networks:
      - sbir-network
    # Resource limits for MacBook Air compatibility
    deploy:
      resources:
        limits:
          memory: 4G
          cpus: '2.0'
        reservations:
          memory: 2G
          cpus: '1.0'
    # Enhanced health check for app container
    healthcheck:
      test: ["CMD-SHELL", "python -c 'import sys; sys.exit(0)'"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s
    # Override default runtime command to run tests and (in CI) install test/dev deps at startup.
    # The app image contains the repository code; we install heavier test dependencies at container start
    # to keep the built image lightweight. This command will:
    #  1) install test dependencies (pip-based fallback)
    #  2) run pytest
    #  3) run a lightweight Dagster in-process job to materialize USPTO assets and evaluate checks
    command: >
      sh -c "
        set -eux;
        echo 'Installing CI test dependencies (pip) inside container';
        # Install only the heavy test/dev packages needed for CI runs.
        # Prefer pip since Poetry is not available in the runtime image.
        pip install --no-cache-dir pandas pyarrow pyreadstat dagster dagit dagster-core || true;
        echo 'Running pytest inside container';
        pytest -q;
        echo 'Running Dagster uspto_validation_job runner (in-process)';
        # Exit non-zero if the runner fails so CI detects the failure.
        python /app/scripts/ci/run_uspto_job.py;
      "
    working_dir: /app
    volumes:
      # Mount workspace for potential test artifacts (optional); CI runner repo is copied into image,
      # but mounting ensures tests that rely on workspace files can access them.
      - ./:/app:ro
      # Mount a writable raw data directory for USPTO test fixtures and asset validations.
      # This allows the Dagster asset `raw_uspto_assignments` to discover files under ./data/raw/uspto.
      - ./data/raw/uspto:/app/data/raw/uspto:rw
    restart: "no"

volumes:
  neo4j_data_ci:
    driver: local
  neo4j_logs_ci:
    driver: local
  neo4j_import_ci:
    driver: local

networks:
  sbir-network:
    name: sbir-test-network
    driver: bridge
