name: Nightly

on:
  schedule:
    - cron: "0 3 * * *"   # 03:00 UTC nightly
  workflow_dispatch:
    inputs:
      mode:
        description: 'Smoke test mode: "dry-run" (no secrets) or "live" (uses NEO4J credentials from secrets or provided inputs)'
        required: false
        default: dry-run
        type: choice
        options:
          - dry-run
          - live
      NEO4J_USER:
        description: "Optional NEO4J user to use for live mode (overrides repository secret if provided)"
        required: false
        default: ""
        type: string
      NEO4J_PASSWORD:
        description: "Optional NEO4J password to use for live mode (overrides repository secret if provided)"
        required: false
        default: ""
        type: string

permissions:
  contents: write          # create branch and commits
  pull-requests: write     # open PR
  actions: read
  checks: read

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  REPAIR_BRANCH_PREFIX: "bot/ci-fix"
  REPAIR_MAX_RUNTIME_MIN: "15"

jobs:
  tests:
    name: Run Nightly Test Suites
    runs-on: ubuntu-latest
    timeout-minutes: 45
    continue-on-error: true
    strategy:
      fail-fast: false
      matrix:
        include:
          - suite: unit
            pytest_target: "tests/unit/"
            pytest_args: '-m "slow" -v'
            needs_neo4j: false
          - suite: integration
            pytest_target: "tests/integration/"
            pytest_args: "-v"
            needs_neo4j: true
          - suite: e2e
            pytest_target: "tests/e2e/"
            pytest_args: "-v"
            needs_neo4j: false
    steps:
      - uses: actions/checkout@v4

      - name: Setup test environment
        uses: ./.github/actions/setup-test-environment
        with:
          python-version: "3.11"
          neo4j-image: "neo4j:5"
          neo4j-username: "neo4j"
          neo4j-password: "password"  # pragma: allowlist secret
          default-timeout: "45"

      - name: Setup Python and UV
        uses: ./.github/actions/setup-python-uv
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          install-dev-deps: "true"
          cache-venv: "true"
          cache-pytest: "false"
          install-pyreadstat: "true"

      - name: Start Neo4j service
        if: matrix.needs_neo4j == true
        run: |
          docker run -d --name nightly-neo4j \
            -e NEO4J_AUTH=${{ env.NEO4J_USERNAME }}/${{ env.NEO4J_PASSWORD }} \
            -p 7687:7687 -p 7474:7474 \
            ${{ env.NEO4J_IMAGE }}
          echo "Waiting for Neo4j..."
          until curl -s -f -o /dev/null http://localhost:7474; do
            echo "Neo4j not ready, sleeping..."
            sleep 5
          done
          echo "Neo4j is ready."

      - name: Run ${{ matrix.suite }} tests
        id: run-tests
        continue-on-error: true
        run: |
          set -o pipefail
          echo "Executing suite: ${{ matrix.suite }}"
          cmd="uv run pytest ${{ matrix.pytest_target }} ${{ matrix.pytest_args }}"
          echo "Command: $cmd"
          eval "$cmd" 2>&1 | tee test-${{ matrix.suite }}.log

      - name: Stop Neo4j service
        if: always() && matrix.needs_neo4j == true
        run: |
          docker stop nightly-neo4j >/dev/null 2>&1 || true
          docker rm nightly-neo4j >/dev/null 2>&1 || true

      - name: Upload logs
        if: always()
        uses: ./.github/actions/upload-artifacts
        with:
          name: nightly-${{ matrix.suite }}-logs
          path: test-${{ matrix.suite }}.log

      - name: Upload suite status
        if: always()
        run: |
          mkdir -p status
          cat <<JSON > status/${{ matrix.suite }}.json
          {
            "suite": "${{ matrix.suite }}",
            "status": "${{ steps.run-tests.outcome }}"
          }
          JSON
      - name: Publish status artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: nightly-status-${{ matrix.suite }}
          path: status/${{ matrix.suite }}.json

  diagnose:
    name: Diagnose Test Failures
    needs: tests
    runs-on: ubuntu-latest
    timeout-minutes: 10
    if: always()
    outputs:
      failed: ${{ steps.summary.outputs.failed }}
    steps:
      - name: Download status artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: nightly-status-*
          merge-multiple: true
          path: statuses
      - name: Summarize results
        id: summary
        run: |
          set -e
          if [ ! -d statuses ]; then
            echo "No status artifacts found."
            echo "failed=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          overall=false
          mkdir -p reports
          for file in statuses/*.json; do
            suite=$(jq -r '.suite' "$file")
            status=$(jq -r '.status' "$file")
            echo "Suite ${suite}: ${status}"
            if [ "$status" != "success" ]; then
              overall=true
            fi
          done
          echo "failed=$overall" >> $GITHUB_OUTPUT
          if [ "$overall" = "true" ]; then
            exit 0
          fi

  attempt_repair:
    name: Attempt minimal, reversible fixes
    needs: diagnose
    if: needs.diagnose.outputs.failed == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 30
    outputs:
      changed: ${{ steps.commit.outputs.changed }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.ref }}

      - name: Create repair branch
        id: branch
        run: |
          short_sha="${GITHUB_SHA::7}"
          branch="${REPAIR_BRANCH_PREFIX}/${short_sha}"
          git switch -c "$branch"
          echo "branch=$branch" >> $GITHUB_OUTPUT

      - name: Setup Python and UV
        uses: ./.github/actions/setup-python-uv
        with:
          python-version: "3.11"
          install-dev-deps: "true"
          cache-venv: "true"
          cache-pytest: "false"
          install-pyreadstat: "false"

      - name: Autofix (black + isort)
        run: |
          uv run black . || true
          uv run isort . || true

      - name: Fix common CI YAML issues
        run: |
          set -e
          shopt -s globstar || true
          for f in .github/workflows/*.yml .github/workflows/*.yaml; do
            [ -f "$f" ] || continue
            sed -i 's/ubuntu-latest/ubuntu-24.04/g' "$f" || true
            sed -i 's/actions\/checkout@v[0-9]*/actions\/checkout@v4/g' "$f" || true
          done

      - name: Commit changes if any
        id: commit
        run: |
          git add -A
          if git diff --cached --quiet; then
            echo "changed=false" >> $GITHUB_OUTPUT
          else
            git -c user.name="ci-bot" -c user.email="actions@users.noreply.github.com" \
              commit -m "ci: minimal nightly repair (lint/format/config)"
            echo "changed=true" >> $GITHUB_OUTPUT
          fi

      - name: Re-run fast tests locally
        id: retest
        if: steps.commit.outputs.changed == 'true'
        run: |
          set -o pipefail
          uv run pytest -m fast -q 2>&1 | tee test-after-fix.log
        continue-on-error: true

      - name: Upload post-fix logs
        if: steps.commit.outputs.changed == 'true'
        uses: ./.github/actions/upload-artifacts
        with:
          name: nightly-test-after-fix
          path: test-after-fix.log

      - name: Open PR with fixes
        if: steps.commit.outputs.changed == 'true'
        uses: peter-evans/create-pull-request@v6
        with:
          branch: ${{ steps.branch.outputs.branch }}
          base: main
          title: "CI: nightly minimal repair"
          commit-message: "ci: minimal nightly repair"
          body: |
            ## Root cause
            Nightly repair attempted after failing tests. See artifacts.

            ## Why this fix
            Applied safe tiers: format, lint, workflow nudges.

            ## Evidence
            Logs attached as workflow artifacts. CI must pass before merge.

            ## Policy
            No edits to release, secrets, or ruleset files. Review required.
          labels: ci:autofix-candidate,bot
          draft: true

  fallback_issue:
    name: Open issue if no safe changes
    needs: [diagnose, attempt_repair]
    if: |
      needs.diagnose.outputs.failed == 'true' &&
      (needs.attempt_repair.result == 'skipped' ||
       needs.attempt_repair.outputs.changed == 'false')
    runs-on: ubuntu-latest
    steps:
      - uses: actions/github-script@v7
        with:
          script: |
            const title = `Nightly CI failure: ${context.sha.substring(0,7)}`;
            const body = `**What failed**
            See nightly logs artifacts.

            **Ask**
            Propose minimal, reversible fix in a PR.
            Link failing tests and rationale.

            **Guardrails**
            No secrets, release, or ruleset changes.`;
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title,
              body,
              labels: ["ci:triage","bot"]
            })

  neo4j-smoke:
    name: Neo4j smoke
    runs-on: ubuntu-latest
    timeout-minutes: 30
    env:
      PROFILE: dev
      # Use dry-run mode for scheduled runs, live mode for manual dispatch with input
      MODE: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.mode || 'dry-run' }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Docker Buildx
        uses: ./.github/actions/setup-docker-buildx

      - name: Prepare .env (dry-run or live)
        uses: ./.github/actions/prepare-env-file
        with:
          neo4j-user: ${{ github.event.inputs.NEO4J_USER != '' && github.event.inputs.NEO4J_USER || secrets.NEO4J_USER }}
          neo4j-password: ${{ github.event.inputs.NEO4J_PASSWORD != '' && github.event.inputs.NEO4J_PASSWORD || secrets.NEO4J_PASSWORD }}

      - name: Build runtime image used for schema / scripts
        run: |
          set -eux
          # Build the runtime target so we can run schema scripts inside a container attached to the compose network.
          docker build --target runtime -t sbir-analytics:smoke .

      - name: Start Neo4j (compose, dev profile)
        run: |
          set -eux
          docker compose --profile dev up -d neo4j

      - name: Wait for Neo4j health (make neo4j-check or docker inspect)
        # In live mode we run the Makefile health check which uses cypher-shell (requires credentials).
        # In dry-run mode we wait for the container to appear running/healthy via docker inspect to avoid requiring credentials.
        run: |
          set -eux
          echo "Health check mode: ${MODE}"
          # Helper: retry loop
          wait_for() {
            cmd="$1"
            tries=0
            until $cmd || [ "$tries" -ge 6 ]; do
              tries=$((tries+1))
              echo "neo4j not ready yet; retry #$tries"
              sleep 5
            done
            if [ "$tries" -ge 6 ]; then
              return 1
            fi
            return 0
          }
          if [ "${MODE}" = "dry-run" ]; then
            echo "Dry-run health check: waiting for neo4j container to be running or report healthy"
            # Prefer health status if available, otherwise check running container presence
            wait_for "sh -c 'status=$(docker inspect --format \"{{.State.Health.Status}}\" sbir-neo4j 2>/dev/null || echo \"\"); \
              if [ \"${status}\" = \"healthy\" ]; then exit 0; fi; \
              if docker ps --filter \"name=sbir-neo4j\" --filter status=running --format \"{{.Names}}\" | grep -q .; then exit 0; fi; exit 1'"
            if [ $? -ne 0 ]; then
              echo "Neo4j did not become ready in time (dry-run)"
              exit 1
            fi
            echo "Neo4j container appears running/healthy (dry-run)"
          else
            echo "Live health check: using Makefile target neo4j-check (requires credentials present)"
            wait_for "make neo4j-check"
            if [ $? -ne 0 ]; then
              echo "Neo4j did not become healthy in time"
              exit 1
            fi
            echo "Neo4j passed live health check"
          fi

      - name: Apply schema (dry-run or live)
        id: apply_schema
        run: |
          set -eux
          # Use the runtime image built above and attach to the compose network so hostname 'neo4j' resolves.
          NETWORK_NAME="sbir-network"
          # Ensure the compose network exists
          docker network inspect "${NETWORK_NAME}" >/dev/null 2>&1 || true

          if [ "${MODE}" = "dry-run" ]; then
            echo "Running apply_schema in dry-run mode"
            docker run --rm --network "${NETWORK_NAME}" -e NEO4J_URI="bolt://neo4j:7687" sbir-analytics:smoke \
              python scripts/neo4j/apply_schema.py --dry-run
          else
            echo "Running apply_schema in live mode (will connect to Neo4j)"
            docker run --rm --network "${NETWORK_NAME}" \
              -e NEO4J_URI="bolt://neo4j:7687" \
              -e NEO4J_USER="${{ secrets.NEO4J_USER }}" \
              -e NEO4J_PASSWORD="${{ secrets.NEO4J_PASSWORD }}" \
              sbir-analytics:smoke python scripts/neo4j/apply_schema.py
          fi

      - name: Smoke test - run a simple cypher query (sanity)
        run: |
          set -eux
          # Attempt a lightweight sanity query using cypher-shell inside a short-lived container.
          # Prefer using docker compose exec if possible; fallback to docker run attached to network.
          if command -v docker-compose >/dev/null 2>&1; then
            # Try exec against running neo4j container
            CONTAINER="$(docker ps --filter 'name=sbir-neo4j' --format '{{.Names}}' | head -n1 || true)"
            if [ -n "$CONTAINER" ]; then
              echo "Running cypher-shell sanity query inside container ${CONTAINER}"
              docker exec "$CONTAINER" sh -c "cypher-shell -u ${NEO4J_USER:-neo4j} -p ${NEO4J_PASSWORD:-password} 'RETURN 1' >/dev/null 2>&1"
            else
              echo "Neo4j container not found by name; attempting to run a temporary container attached to compose network"
              docker run --rm --network sbir-network byrnedo/alpine-curl:latest sh -c "apk add --no-cache openjdk11-jre-headless jq || true; echo 'sanity check placeholder'"
            fi
          else
            echo "docker-compose not detected; skipping exec sanity check"
          fi

      # Always attempt to tear down compose resources (but do not remove named volumes by default)
      - name: Tear down compose (always)
        if: ${{ always() }}
        run: |
          set -eux
          docker compose --profile dev down --remove-orphans --volumes

      - name: Upload logs and artifacts on failure
        if: failure()
        uses: ./.github/actions/upload-artifacts
        with:
          name: neo4j-smoke-logs
          path: |
            logs/
            reports/ || true
          if-no-files-found: ignore

      - name: Success note
        if: ${{ success() }}
        run: echo "Neo4j smoke test completed successfully (mode=${MODE})"

  markdown-lint:
    name: Markdown Lint
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      - name: Install markdownlint-cli2
        run: npm install -g markdownlint-cli2
      - name: Run markdownlint-cli2
        run: |
          markdownlint-cli2 "**/*.md" \
            --config .markdownlint.yaml \
            --ignore "**/archive/**/*.md" \
            --ignore "**/.kiro/specs/archive/**/*.md" \
            --ignore "reports/**/*.md" \
            --ignore "**/.venv/**/*.md" \
            --ignore "**/venv/**/*.md" \
            --ignore "**/node_modules/**/*.md"
