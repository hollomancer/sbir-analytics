name: Nightly

on:
  schedule:
    - cron: "0 3 * * *"   # 03:00 UTC nightly
  workflow_dispatch:
    inputs:
      mode:
        description: 'Smoke test mode: "dry-run" (no secrets) or "live" (uses NEO4J credentials from secrets or provided inputs)'
        required: false
        default: dry-run
        type: choice
        options:
          - dry-run
          - live
      NEO4J_USER:
        description: "Optional NEO4J user to use for live mode (overrides repository secret if provided)"
        required: false
        default: ""
        type: string
      NEO4J_PASSWORD:
        description: "Optional NEO4J password to use for live mode (overrides repository secret if provided)"
        required: false
        default: ""
        type: string

permissions:
  contents: write          # create branch and commits
  pull-requests: write     # open PR
  actions: read
  checks: read

env:
  REPAIR_BRANCH_PREFIX: "bot/ci-fix"
  REPAIR_MAX_RUNTIME_MIN: "15"

jobs:
  test-unit:
    name: Run Unit Tests
    runs-on: ubuntu-latest
    timeout-minutes: 30
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install Poetry
        run: |
          curl -sSL https://install.python-poetry.org | python3 -
          echo "$HOME/.local/bin" >> $GITHUB_PATH

      - name: Configure Poetry
        run: |
          poetry config virtualenvs.create true
          poetry config virtualenvs.in-project true

      - name: Cache Poetry virtual environment
        uses: actions/cache@v3
        with:
          path: .venv
          key: venv-${{ runner.os }}-3.11-${{ hashFiles('**/poetry.lock') }}
          restore-keys: |
            venv-${{ runner.os }}-3.11-

      - name: Install dependencies
        run: poetry install --no-interaction

      - name: Install duckdb and pyreadstat
        run: |
          poetry run python -m pip install --upgrade pip
          poetry run pip install duckdb pyreadstat

      - name: Run unit tests
        id: test
        run: |
          set -o pipefail
          poetry run pytest tests/unit/ -v 2>&1 | tee test-unit.log
        continue-on-error: true

      - name: Upload logs
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: nightly-unit-test-logs
          path: test-unit.log

      - name: Set failure flag
        id: flags
        run: |
          if [ "${{ steps.test.outcome }}" != "success" ]; then
            echo "failed=true" >> $GITHUB_OUTPUT
          else
            echo "failed=false" >> $GITHUB_OUTPUT
          fi

  test-integration:
    name: Run Integration Tests
    runs-on: ubuntu-latest
    timeout-minutes: 30
    services:
      neo4j:
        image: neo4j:5
        ports:
          - 7687:7687
          - 7474:7474
        env:
          NEO4J_AUTH: neo4j/password
        options: >-
          --health-cmd="bash -c 'cypher-shell -u neo4j -p password \"RETURN 1\" || exit 1'"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=12
    env:
      NEO4J_URI: bolt://localhost:7687
      NEO4J_USERNAME: neo4j
      NEO4J_PASSWORD: password
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install Poetry
        run: |
          curl -sSL https://install.python-poetry.org | python3 -
          echo "$HOME/.local/bin" >> $GITHUB_PATH

      - name: Configure Poetry
        run: |
          poetry config virtualenvs.create true
          poetry config virtualenvs.in-project true

      - name: Cache Poetry virtual environment
        uses: actions/cache@v3
        with:
          path: .venv
          key: venv-${{ runner.os }}-3.11-${{ hashFiles('**/poetry.lock') }}
          restore-keys: |
            venv-${{ runner.os }}-3.11-

      - name: Install dependencies
        run: poetry install --no-interaction

      - name: Install duckdb and pyreadstat
        run: |
          poetry run python -m pip install --upgrade pip
          poetry run pip install duckdb pyreadstat

      - name: Wait for Neo4j
        run: |
          echo "Waiting for Neo4j to be ready..."
          until curl -s -f -o /dev/null "http://localhost:7474"; do
            echo "Neo4j not ready, sleeping..."
            sleep 5
          done
          echo "Neo4j is ready!"

      - name: Run integration tests
        id: test
        run: |
          set -o pipefail
          poetry run pytest tests/integration/ -v 2>&1 | tee test-integration.log
        continue-on-error: true

      - name: Upload logs
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: nightly-integration-test-logs
          path: test-integration.log

      - name: Set failure flag
        id: flags
        run: |
          if [ "${{ steps.test.outcome }}" != "success" ]; then
            echo "failed=true" >> $GITHUB_OUTPUT
          else
            echo "failed=false" >> $GITHUB_OUTPUT
          fi

  test-e2e:
    name: Run E2E Tests
    runs-on: ubuntu-latest
    timeout-minutes: 45
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install Poetry
        run: |
          curl -sSL https://install.python-poetry.org | python3 -
          echo "$HOME/.local/bin" >> $GITHUB_PATH

      - name: Configure Poetry
        run: |
          poetry config virtualenvs.create true
          poetry config virtualenvs.in-project true

      - name: Cache Poetry virtual environment
        uses: actions/cache@v3
        with:
          path: .venv
          key: venv-${{ runner.os }}-3.11-${{ hashFiles('**/poetry.lock') }}
          restore-keys: |
            venv-${{ runner.os }}-3.11-

      - name: Install dependencies
        run: poetry install --no-interaction

      - name: Install duckdb and pyreadstat
        run: |
          poetry run python -m pip install --upgrade pip
          poetry run pip install duckdb pyreadstat

      - name: Run E2E tests
        id: test
        run: |
          set -o pipefail
          poetry run pytest tests/e2e/ -v 2>&1 | tee test-e2e.log
        continue-on-error: true

      - name: Upload logs
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: nightly-e2e-test-logs
          path: test-e2e.log

      - name: Set failure flag
        id: flags
        run: |
          if [ "${{ steps.test.outcome }}" != "success" ]; then
            echo "failed=true" >> $GITHUB_OUTPUT
          else
            echo "failed=false" >> $GITHUB_OUTPUT
          fi

  diagnose:
    name: Diagnose Test Failures
    needs: [test-unit, test-integration, test-e2e]
    runs-on: ubuntu-latest
    if: |
      needs.test-unit.outputs.failed == 'true' ||
      needs.test-integration.outputs.failed == 'true' ||
      needs.test-e2e.outputs.failed == 'true'
    steps:
      - name: Set failure flag
        id: flags
        run: |
          echo "failed=true" >> $GITHUB_OUTPUT

  attempt_repair:
    name: Attempt minimal, reversible fixes
    needs: diagnose
    if: needs.diagnose.outputs.failed == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 30
    outputs:
      changed: ${{ steps.commit.outputs.changed }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.ref }}

      - name: Create repair branch
        id: branch
        run: |
          short_sha="${GITHUB_SHA::7}"
          branch="${REPAIR_BRANCH_PREFIX}/${short_sha}"
          git switch -c "$branch"
          echo "branch=$branch" >> $GITHUB_OUTPUT

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install formatters
        run: python -m pip install --disable-pip-version-check -q black isort

      - name: Autofix (black + isort)
        run: |
          black . || true
          isort . || true

      - name: Fix common CI YAML issues
        run: |
          set -e
          shopt -s globstar || true
          for f in .github/workflows/*.yml .github/workflows/*.yaml; do
            [ -f "$f" ] || continue
            sed -i 's/ubuntu-latest/ubuntu-24.04/g' "$f" || true
            sed -i 's/actions\/checkout@v[0-9]*/actions\/checkout@v4/g' "$f" || true
          done

      - name: Commit changes if any
        id: commit
        run: |
          git add -A
          if git diff --cached --quiet; then
            echo "changed=false" >> $GITHUB_OUTPUT
          else
            git -c user.name="ci-bot" -c user.email="actions@users.noreply.github.com" \
              commit -m "ci: minimal nightly repair (lint/format/config)"
            echo "changed=true" >> $GITHUB_OUTPUT
          fi

      - name: Re-run fast tests locally
        id: retest
        if: steps.commit.outputs.changed == 'true'
        run: |
          set -o pipefail
          # Need to install dependencies before running tests
          curl -sSL https://install.python-poetry.org | python3 -
          poetry install --no-interaction
          poetry run pytest -m fast -q 2>&1 | tee test-after-fix.log
        continue-on-error: true

      - name: Upload post-fix logs
        uses: actions/upload-artifact@v4
        if: steps.commit.outputs.changed == 'true'
        with:
          name: nightly-test-after-fix
          path: test-after-fix.log

      - name: Open PR with fixes
        if: steps.commit.outputs.changed == 'true'
        uses: peter-evans/create-pull-request@v6
        with:
          branch: ${{ steps.branch.outputs.branch }}
          title: "CI: nightly minimal repair"
          commit-message: "ci: minimal nightly repair"
          body: |
            ## Root cause
            Nightly repair attempted after failing tests. See artifacts.

            ## Why this fix
            Applied safe tiers: format, lint, workflow nudges.

            ## Evidence
            Logs attached as workflow artifacts. CI must pass before merge.

            ## Policy
            No edits to release, secrets, or ruleset files. Review required.
          labels: ci:autofix-candidate,bot
          draft: true

  fallback_issue:
    name: Open issue if no safe changes
    needs: [diagnose, attempt_repair]
    if: |
      needs.diagnose.outputs.failed == 'true' &&
      (needs.attempt_repair.result == 'skipped' ||
       needs.attempt_repair.outputs.changed == 'false')
    runs-on: ubuntu-latest
    steps:
      - uses: actions/github-script@v7
        with:
          script: |
            const title = `Nightly CI failure: ${context.sha.substring(0,7)}`;
            const body = `**What failed**
            See nightly logs artifacts.

            **Ask**
            Propose minimal, reversible fix in a PR.
            Link failing tests and rationale.

            **Guardrails**
            No secrets, release, or ruleset changes.`;
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title,
              body,
              labels: ["ci:triage","bot"]
            })

  neo4j-smoke:
    name: Neo4j smoke
    runs-on: ubuntu-latest
    timeout-minutes: 30
    env:
      COMPOSE_FILE: docker-compose.yml:docker/neo4j.compose.override.yml
      PROFILE: neo4j
      # Use dry-run mode for scheduled runs, live mode for manual dispatch with input
      MODE: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.mode || 'dry-run' }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Prepare .env (dry-run or live)
        run: |
          set -eux
          # Ensure we have a .env for compose; start from example if present
          if [ -f .env.example ]; then
            cp .env.example .env || true
          else
            touch .env
          fi

          # If running in live mode, prefer inputs; fall back to repository secrets if inputs are empty.
          if [ "${MODE}" = "live" ]; then
            # Capture potential inputs (may be empty strings if not provided)
            NEO4J_INPUT_USER="${{ github.event.inputs.NEO4J_USER }}"
            NEO4J_INPUT_PASSWORD="${{ github.event.inputs.NEO4J_PASSWORD }}"

            # If inputs are empty, fall back to repo secrets (may also be empty)
            if [ -z "${NEO4J_INPUT_USER}" ]; then
              NEO4J_INPUT_USER="${{ secrets.NEO4J_USER }}"
            fi
            if [ -z "${NEO4J_INPUT_PASSWORD}" ]; then
              NEO4J_INPUT_PASSWORD="${{ secrets.NEO4J_PASSWORD }}"
            fi

            # Fail if we still do not have a password (cannot proceed in live mode)
            if [ -z "${NEO4J_INPUT_PASSWORD}" ]; then
              echo "NEO4J_PASSWORD not provided via inputs or repository secrets; failing live run."
              exit 2
            fi

            # Append or override values in .env (simple append; prefer inputs first, then secrets)
            echo "NEO4J_USER=${NEO4J_INPUT_USER}" >> .env
            echo "NEO4J_PASSWORD=${NEO4J_INPUT_PASSWORD}" >> .env
            # Optionally set NEO4J_AUTH
            echo "NEO4J_AUTH=${NEO4J_INPUT_USER}/${NEO4J_INPUT_PASSWORD}" >> .env
          else
            echo "Dry-run mode: no secrets injected."
          fi

      - name: Build runtime image used for schema / scripts
        run: |
          set -eux
          # Build the runtime target so we can run schema scripts inside a container attached to the compose network.
          docker build --target runtime -t sbir-etl:smoke .

      - name: Start Neo4j (compose, neo4j profile)
        run: |
          set -eux
          docker compose -f docker-compose.yml -f docker/neo4j.compose.override.yml --profile neo4j up -d --build

      - name: Wait for Neo4j health (make neo4j-check or docker inspect)
        # In live mode we run the Makefile health check which uses cypher-shell (requires credentials).
        # In dry-run mode we wait for the container to appear running/healthy via docker inspect to avoid requiring credentials.
        run: |
          set -eux
          echo "Health check mode: ${MODE}"
          # Helper: retry loop
          wait_for() {
            cmd="$1"
            tries=0
            until $cmd || [ "$tries" -ge 6 ]; do
              tries=$((tries+1))
              echo "neo4j not ready yet; retry #$tries"
              sleep 5
            done
            if [ "$tries" -ge 6 ]; then
              return 1
            fi
            return 0
          }
          if [ "${MODE}" = "dry-run" ]; then
            echo "Dry-run health check: waiting for neo4j container to be running or report healthy"
            # Prefer health status if available, otherwise check running container presence
            wait_for "sh -c 'status=$(docker inspect --format \"{{.State.Health.Status}}\" sbir-neo4j 2>/dev/null || echo \"\"); \
              if [ \"${status}\" = \"healthy\" ]; then exit 0; fi; \
              if docker ps --filter \"name=sbir-neo4j\" --filter status=running --format \"{{.Names}}\" | grep -q .; then exit 0; fi; exit 1'"
            if [ $? -ne 0 ]; then
              echo "Neo4j did not become ready in time (dry-run)"
              exit 1
            fi
            echo "Neo4j container appears running/healthy (dry-run)"
          else
            echo "Live health check: using Makefile target neo4j-check (requires credentials present)"
            wait_for "make neo4j-check"
            if [ $? -ne 0 ]; then
              echo "Neo4j did not become healthy in time"
              exit 1
            fi
            echo "Neo4j passed live health check"
          fi

      - name: Apply schema (dry-run or live)
        id: apply_schema
        run: |
          set -eux
          # Use the runtime image built above and attach to the compose network so hostname 'neo4j' resolves.
          NETWORK_NAME="sbir-network"
          # Ensure the compose network exists
          docker network inspect "${NETWORK_NAME}" >/dev/null 2>&1 || true

          if [ "${MODE}" = "dry-run" ]; then
            echo "Running apply_schema in dry-run mode"
            docker run --rm --network "${NETWORK_NAME}" -e NEO4J_URI="bolt://neo4j:7687" sbir-etl:smoke \
              python scripts/neo4j/apply_schema.py --dry-run
          else
            echo "Running apply_schema in live mode (will connect to Neo4j)"
            docker run --rm --network "${NETWORK_NAME}" \
              -e NEO4J_URI="bolt://neo4j:7687" \
              -e NEO4J_USER="${{ secrets.NEO4J_USER }}" \
              -e NEO4J_PASSWORD="${{ secrets.NEO4J_PASSWORD }}" \
              sbir-etl:smoke python scripts/neo4j/apply_schema.py
          fi

      - name: Smoke test - run a simple cypher query (sanity)
        run: |
          set -eux
          # Attempt a lightweight sanity query using cypher-shell inside a short-lived container.
          # Prefer using docker compose exec if possible; fallback to docker run attached to network.
          if command -v docker-compose >/dev/null 2>&1; then
            # Try exec against running neo4j container
            CONTAINER="$(docker ps --filter 'name=sbir-neo4j' --format '{{.Names}}' | head -n1 || true)"
            if [ -n "$CONTAINER" ]; then
              echo "Running cypher-shell sanity query inside container ${CONTAINER}"
              docker exec "$CONTAINER" sh -c "cypher-shell -u ${NEO4J_USER:-neo4j} -p ${NEO4J_PASSWORD:-password} 'RETURN 1' >/dev/null 2>&1"
            else
              echo "Neo4j container not found by name; attempting to run a temporary container attached to compose network"
              docker run --rm --network sbir-network byrnedo/alpine-curl:latest sh -c "apk add --no-cache openjdk11-jre-headless jq || true; echo 'sanity check placeholder'"
            fi
          else
            echo "docker-compose not detected; skipping exec sanity check"
          fi

      # Always attempt to tear down compose resources (but do not remove named volumes by default)
      - name: Tear down compose (always)
        if: ${{ always() }}
        run: |
          set -eux
          docker compose -f docker-compose.yml -f docker/neo4j.compose.override.yml --profile neo4j down --remove-orphans

      - name: Upload logs and artifacts on failure
        if: ${{ failure() }}
        uses: actions/upload-artifact@v4
        with:
          name: neo4j-smoke-logs
          path: |
            logs/
            reports/ || true

      - name: Success note
        if: ${{ success() }}
        run: echo "Neo4j smoke test completed successfully (mode=${MODE})"

  markdown-lint:
    name: Markdown Lint
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      - name: Install markdownlint-cli2
        run: npm install -g markdownlint-cli2
      - name: Run markdownlint-cli2
        run: |
          markdownlint-cli2 "**/*.md" \
            --config .markdownlint.yaml \
            --ignore "**/archive/**/*.md" \
            --ignore "**/.kiro/specs/archive/**/*.md" \
            --ignore "reports/**/*.md" \
            --ignore "**/.venv/**/*.md" \
            --ignore "**/venv/**/*.md" \
            --ignore "**/node_modules/**/*.md"

