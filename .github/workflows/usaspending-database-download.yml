name: USAspending Database Download (DEPRECATED - Use data-refresh.yml)

# ⚠️ DEPRECATION NOTICE:
# This workflow has been consolidated into data-refresh.yml
# Use the new unified workflow for all data refresh operations.
# This file is kept temporarily for reference and will be removed in a future release.

on:
  schedule:
    # Run monthly on the 6th at 2 AM UTC (USAspending typically updates monthly around the 6th)
    - cron: "0 2 6 * *"
  workflow_dispatch:
    inputs:
      database_type:
        description: "Database type to download"
        required: true
        type: choice
        options:
          - full
          - test
        default: "full"
      date:
        description: "Date in YYYYMMDD format (defaults to current month)"
        required: false
        type: string
      source_url:
        description: "Override source URL (optional)"
        required: false
        type: string
      force_refresh:
        description: "Force refresh even if file already exists"
        required: false
        default: false
        type: boolean

permissions:
  id-token: write  # For OIDC authentication to AWS
  contents: read   # Only read access needed

concurrency:
  group: usaspending-database-download
  cancel-in-progress: false

env:
  AWS_REGION: us-east-2
  S3_BUCKET: sbir-etl-production-data
  EC2_INSTANCE_ID: ${{ secrets.EC2_INSTANCE_ID }}  # EC2 instance ID for downloads
  EC2_INSTANCE_TYPE: t3.large  # Instance type if creating new instance

jobs:
  download-usaspending-database:
    runs-on: ubuntu-latest
    timeout-minutes: 180  # Allow up to 3 hours for large downloads
    steps:
      - name: Configure AWS credentials
        uses: ./.github/actions/setup-aws-credentials
        with:
          role-arn: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install Python dependencies
        run: |
          python3 -m pip install --quiet boto3

      - name: Check if new file is available
        id: check_file
        run: |
          # Check if a new file is available before downloading
          python3 scripts/usaspending/check_new_file.py \
            --s3-bucket "${{ env.S3_BUCKET }}" \
            --database-type "${{ github.event.inputs.database_type || 'full' }}" \
            --date "${{ github.event.inputs.date || '' }}" \
            --source-url "${{ github.event.inputs.source_url || '' }}" \
            --json > /tmp/file_check.json || true

          # Parse result
          if [ -f /tmp/file_check.json ]; then
            IS_NEW=$(jq -r '.is_new // false' /tmp/file_check.json)
            AVAILABLE=$(jq -r '.available // false' /tmp/file_check.json)

            echo "is_new=$IS_NEW" >> $GITHUB_OUTPUT
            echo "available=$AVAILABLE" >> $GITHUB_OUTPUT

            if [ "$IS_NEW" = "true" ]; then
              echo "✅ New file detected - will download"
            elif [ "$AVAILABLE" = "false" ]; then
              echo "⚠️ File not available at source URL"
            else
              echo "ℹ️ File exists but is not new (already in S3)"
            fi
          else
            echo "is_new=true" >> $GITHUB_OUTPUT
            echo "available=true" >> $GITHUB_OUTPUT
            echo "⚠️ Could not check file availability, proceeding with download"
          fi

      - name: Skip download if file not new
        if: steps.check_file.outputs.is_new == 'false' && github.event.inputs.force_refresh != 'true'
        run: |
          echo "File is not new and force_refresh is not enabled. Skipping download."
          echo "To force download, set force_refresh=true"
          exit 0

      - name: Prepare download command
        id: prepare_command
        if: steps.check_file.outputs.is_new == 'true' || github.event.inputs.force_refresh == 'true'
        run: |
          # Build command arguments
          ARGS="--s3-bucket ${{ env.S3_BUCKET }}"
          ARGS="$ARGS --database-type ${{ github.event.inputs.database_type || 'full' }}"

          if [ -n "${{ github.event.inputs.date }}" ]; then
            ARGS="$ARGS --date ${{ github.event.inputs.date }}"
          fi

          if [ -n "${{ github.event.inputs.source_url }}" ]; then
            ARGS="$ARGS --source-url ${{ github.event.inputs.source_url }}"
          fi

          if [ "${{ github.event.inputs.force_refresh || 'false' }}" = "true" ]; then
            ARGS="$ARGS --force-refresh"
          fi

          echo "command_args=$ARGS" >> $GITHUB_OUTPUT

      - name: Check if EC2 instance exists
        id: check_instance
        run: |
          if [ -z "${{ env.EC2_INSTANCE_ID }}" ]; then
            echo "EC2_INSTANCE_ID not set. Will create new instance."
            echo "instance_exists=false" >> $GITHUB_OUTPUT
          else
            # Check if instance exists and get its state
            INSTANCE_STATE=$(aws ec2 describe-instances \
              --instance-ids "${{ env.EC2_INSTANCE_ID }}" \
              --query 'Reservations[0].Instances[0].State.Name' \
              --output text 2>/dev/null || echo "not-found")

            if [ "$INSTANCE_STATE" = "not-found" ] || [ -z "$INSTANCE_STATE" ]; then
              echo "Instance not found. Will create new instance."
              echo "instance_exists=false" >> $GITHUB_OUTPUT
            else
              echo "instance_exists=true" >> $GITHUB_OUTPUT
              echo "instance_state=$INSTANCE_STATE" >> $GITHUB_OUTPUT
            fi
          fi

      - name: Start EC2 instance
        if: steps.check_instance.outputs.instance_exists == 'true'
        id: start_instance
        run: |
          INSTANCE_ID="${{ env.EC2_INSTANCE_ID }}"
          CURRENT_STATE=$(aws ec2 describe-instances \
            --instance-ids "$INSTANCE_ID" \
            --query 'Reservations[0].Instances[0].State.Name' \
            --output text)

          if [ "$CURRENT_STATE" = "stopped" ]; then
            echo "Starting EC2 instance: $INSTANCE_ID"
            aws ec2 start-instances --instance-ids "$INSTANCE_ID"

            # Wait for instance to be running
            echo "Waiting for instance to be running..."
            aws ec2 wait instance-running --instance-ids "$INSTANCE_ID"

            # Wait a bit more for SSM agent to be ready
            echo "Waiting for SSM agent to be ready..."
            sleep 30

            echo "Instance is ready"
          elif [ "$CURRENT_STATE" = "running" ]; then
            echo "Instance is already running"
          else
            echo "Instance is in state: $CURRENT_STATE"
            exit 1
          fi

          # Get instance IP for reference
          INSTANCE_IP=$(aws ec2 describe-instances \
            --instance-ids "$INSTANCE_ID" \
            --query 'Reservations[0].Instances[0].PublicIpAddress' \
            --output text)

          echo "instance_ip=$INSTANCE_IP" >> $GITHUB_OUTPUT

      - name: Upload script to EC2 instance
        if: steps.check_instance.outputs.instance_exists == 'true'
        run: |
          INSTANCE_ID="${{ env.EC2_INSTANCE_ID }}"

          # Upload the Python script from the repo to EC2 using base64 encoding
          # Read script and encode (GitHub Actions runs on Linux, so -w 0 works)
          SCRIPT_CONTENT=$(base64 -w 0 < scripts/usaspending/download_database.py)

          # Upload via SSM - create script file on EC2
          UPLOAD_CMD_ID=$(aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters "commands=[
              'mkdir -p /tmp/sbir-download',
              'echo \"$SCRIPT_CONTENT\" | base64 -d > /tmp/sbir-download/download_database.py',
              'chmod +x /tmp/sbir-download/download_database.py',
              'python3 -m pip install --user boto3 --quiet || true'
            ]" \
            --query 'Command.CommandId' \
            --output text)

          # Wait for upload to complete
          echo "Waiting for script upload to complete..."
          aws ssm wait command-executed \
            --command-id "$UPLOAD_CMD_ID" \
            --instance-id "$INSTANCE_ID" || true

          sleep 5  # Extra wait for pip install if needed

          echo "Script uploaded to EC2 instance"

      - name: Execute download on EC2
        if: steps.check_instance.outputs.instance_exists == 'true'
        id: execute_download
        run: |
          INSTANCE_ID="${{ env.EC2_INSTANCE_ID }}"
          COMMAND_ARGS="${{ steps.prepare_command.outputs.command_args }}"

          # Execute download script via SSM
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters "commands=[
              'cd /tmp/sbir-download',
              'python3 download_database.py $COMMAND_ARGS'
            ]" \
            --query 'Command.CommandId' \
            --output text)

          echo "command_id=$COMMAND_ID" >> $GITHUB_OUTPUT
          echo "Executing download on EC2 instance. Command ID: $COMMAND_ID"

          # Wait for command to complete (with timeout)
          echo "Waiting for download to complete (this may take 2-3 hours for full database)..."
          TIMEOUT=10800  # 3 hours in seconds
          ELAPSED=0
          INTERVAL=30  # Check every 30 seconds

          while [ $ELAPSED -lt $TIMEOUT ]; do
            STATUS=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" \
              --query 'Status' \
              --output text 2>/dev/null || echo "InProgress")

            if [ "$STATUS" = "Success" ]; then
              echo "Download completed successfully!"
              break
            elif [ "$STATUS" = "Failed" ] || [ "$STATUS" = "Cancelled" ] || [ "$STATUS" = "TimedOut" ]; then
              echo "Download failed with status: $STATUS"
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "$INSTANCE_ID" \
                --output json
              exit 1
            fi

            sleep $INTERVAL
            ELAPSED=$((ELAPSED + INTERVAL))
            echo "Still running... ($ELAPSED seconds elapsed)"
          done

          if [ $ELAPSED -ge $TIMEOUT ]; then
            echo "Download timed out after $TIMEOUT seconds"
            exit 1
          fi

          # Get command output
          aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "$INSTANCE_ID" \
            --output text

      - name: Stop EC2 instance
        if: always() && steps.check_instance.outputs.instance_exists == 'true'
        run: |
          INSTANCE_ID="${{ env.EC2_INSTANCE_ID }}"

          echo "Stopping EC2 instance: $INSTANCE_ID"
          aws ec2 stop-instances --instance-ids "$INSTANCE_ID"

          # Wait for instance to stop
          aws ec2 wait instance-stopped --instance-ids "$INSTANCE_ID"

          echo "Instance stopped successfully"

      - name: Display results
        if: success()
        run: |
          echo "## USAspending Database Download Complete"
          echo ""
          echo "**Database Type:** ${{ github.event.inputs.database_type || 'full' }}"
          echo "**S3 Bucket:** ${{ env.S3_BUCKET }}"
          echo ""
          echo "Check S3 for the downloaded file:"
          echo "s3://${{ env.S3_BUCKET }}/raw/usaspending/database/"
